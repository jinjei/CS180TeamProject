package UI;

import common.User;
import util.FileUtil;
import util.FrameUtil;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * A frame used for displaying and managing a user's block list in a chat application.
 *
 * <p>This frame provides functionalities to view and manage users that are currently blocked by the user.
 * Users can be unblocked using the interface provided by this frame.</p>
 */

public class BlockListFrame {
    private JPanel root;
    private JButton removeBtn;
    private JTable table1;

    private Object[][] userData;
    private final Object[] columnNames = {"", "Icon", "Username"};
    private Set<String> selectedUsernames = new HashSet<>();
    private User currentUser;
    private JFrame frame;
    private ConcurrentHashMap<String, User> users;

    public BlockListFrame(ConcurrentHashMap<String, User> users, User user) {
        this.users = users;
        this.currentUser = user;
        setupFrame();
        CustomModel model = new CustomModel();
        setupTable(model);
        setupListeners(model);
    }

    private void setupFrame() {
        frame = new JFrame("BlockList");
        frame.setContentPane(this.root);
        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        frame.setSize(500, 300);
        FrameUtil.center(frame);
        frame.setVisible(true);
    }

    private void setupTable(CustomModel model) {
        for (Object column : columnNames) {
            model.addColumn(column);
        }
        init(model, users);
        table1.setModel(model);
        table1.setRowHeight(80);
    }

    private void setupListeners(CustomModel model) {
        removeBtn.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                handleRemoveButton(model);
            }
        });
    }

    public void init(CustomModel model, ConcurrentHashMap<String, User> users) {
        model.setRowCount(0);
        userData = new Object[users.size()][3];
        int i = 0;
        for (String key : currentUser.getBlockedUsers()) {
            User user = users.get(key);
            if (user != null) {
                userData[i][0] = Boolean.FALSE;
                userData[i][1] = user.getBio();
                userData[i][2] = user.getUsername();
                model.addRow(userData[i]);
                i++;
            }
        }
    }

    class CustomModel extends DefaultTableModel {
        @Override
        public boolean isCellEditable(int row, int column) {
            return column == 0; // Only the checkbox column should be editable
        }

        @Override
        public Class<?> getColumnClass(int columnIndex) {
            return getValueAt(0, columnIndex).getClass();
        }

        @Override
        public void setValueAt(Object aValue, int row, int column) {
            super.setValueAt(aValue, row, column);
            if (column == 0) {
                String username = (String) getValueAt(row, 2);
                if ((Boolean) aValue) {
                    selectedUsernames.add(username);
                } else {
                    selectedUsernames.remove(username);
                }
            }
        }
    }

    private void handleRemoveButton(CustomModel model) {
        if (selectedUsernames.isEmpty()) {
            JOptionPane.showMessageDialog(root, "Please select at least one person");
        } else {
            selectedUsernames.forEach(username -> {
                currentUser.unblockUser(username);
                JOptionPane.showMessageDialog(root, "User " + username + " has been unblocked.");
            });
            refreshData(model);
            selectedUsernames.clear();
        }
    }

    private void refreshData(CustomModel model) {
        users = FileUtil.getUsers();
        UserInterfaceFrame.getInstance().flush();
        init(model, users);
    }
}
